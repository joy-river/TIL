### 데이터 처리 명령어

---

# ADD, ADC

---

- ADD는 단순한 덧셈을 계산한다.

  ```
  add r0, r1, #12 ; (r0 = r1 + 12)

  adds r0, r1, #30 ; add의 결과로 CPSR을 업데이트 한다

  cmp r1, r2
  addgt r0, r1, r2 ; r1와 r2를 비교해서, r1이 더 크면 add를 수행하고 아니면 무시한다.
  ```

- ADC(ADD with carry)는 C 플래그와 함께 덧셈을 수행한다.

  - 이를 통해 32비트를 초과하는 덧셈도 가능하다!

  ```
  64비트 상수를 두 레지스터로 표현한다.
  rn = r5 and r4
  rm = r9 and r8

  adds r0, r4, r8
  adcs r1, r5, r9
  ```

# SUB, SBC

---

- SUB는 뺄셈을 수행한다.

  - 사실상 2의 보수를 통한 덧셈을 실행한다.

- SBC는 두 연산자를 C 비트와 함께 뺀다

  - 32비트 초과 뺄셈도 가능하다!

# CLZ

---

- CLZ(Count Leading Zero)는 1 값을 가진 비트가 나올 때 까지 몇 개의 0비트가 나왔는지 계산한다.

  ```
  r0 = 0x0000_0001_0000_....

  clz r1, r0      ; r1에 7이 기록된다
  ```

  - 당연히 MSB가 1이면 0을 반환한다.

# AND, ORR, EOR, BIC

---

- 논리적인 연산 and, or, xor을 수행한다.

  ```
  eor r0, r0, r0은 ; r0을 모두 0으로 만든다
  bic r0, r0, r1   ; r0에서 r1에 있는 값은 모두 없앤다.
  ```

# CMP

---

- 두 레지스터 값을 비교할 때 사용한다.

  - V 플래그를 제외한 N, Z, C 플래그가 업데이트된다.

- CMP는 r0 - r1으로 비교한다.

- CMN은 r0 - (-r1)으로 비교한다.

- TST는 r0 and r1으로 비교한다.

- TEQ는 r0 xor r1으로 비교한다.

### Branch Instruction

---

# B, BL

---

- B는 특정 라벨(Label)로 브랜치 한다

  ```
  b foo       ; foo로 브랜치 한다.
  ```

  - 브랜치는 pc를 다른 메모리 주소를 가리키게끔 덮어쓰는 것이다.

    - 라벨이 바로 다른 메모리 주소를 의미한다.

    - Execution flow를 바꾼다.

  - 브랜치에도 접미사를 붙일 수 있다.

- BL은 특정 라벨로 분기하나, r14(=Link register)에 돌아올 메모리 주소를 저장해놓는다.

  - L 비트를 따로 사용하며, L이 1인 경우 lr에 주소를 저장한다.

  - 만약 함수 내부에서 다시 한 번 BL을 호출하면 lr값이 덮어씌워져 원래 위치로 돌아오지 못할 수도 있다.

  - 원래 코드 위치로 돌아오기 위해서 pc에 lr 값을 복사한다.

    ```
    mov pc(=r15), lr(=r14) ; 원래 위치로 돌아온다.
    ```

- 분기의 원리는 다음과 같다.

  - 분기 명령어는 24비트 signed_immediate가 존재한다.

    - 이 24비트가 분기할 목적지 주소가 된다.

  - 이 24비트는 목적지 주소까지 몇개의 명령어를 건너가면 되는지 저장하고 있다.

    - 이 주소는 현재 PC값에 대해 상대적이다.

    - 명령어의 개수 \* 4(바이트) 만큼의 주소를 이동해야 하므로 명령어의 개수에 << 2 를 계산한다.

      - 따라서 +- 32MB 만큼 분기할 수 있다.

    - 이를 PC + 8에 더한다.

  - 왜 PC값에 8을 더하냐면, 파이프라인에서 ALU에 PC값을 넣는 시점에 이미 PC가 8만큼 진행되어 있기 때문이다.

    ```
    foo:
        b foo
    ```

    - (PC + 8) - (? \* 4) = PC, ? = -2 개의 명령어만큼 뒤로 움직이면 된다.

### Memory Access Instruction

---

- Single-Register Transfer

  - ldr

    - 특정 주소에 있는 값을 불러온다.

    ```
    ldr r0, [r1] ; r1 레지스터의 메모리 주소에 위치한 값을 불러온다.

    ldr r0, [r1 + #4] ; r1 + 4에서 불러온다. = offset

    ldr r0, [r1], #4  ; r1에서 불러오고, r1 += 4를 진행한다. = post-indexed

    ldr r0, [r1, #4]! ; r1 += 4를 진행하고, r1에서 불러온다. = pre-indexed
    ```

  - str

    - 특정 주소에 값을 저장한다.

    - arm 프로세서는 little endian을 사용한다.

      - little endian은 주소를 내림차순으로 기록한다.

      - 0x0a0b0c0d라는 값이 있다고 가정하자.

        - 각 바이트 0a, 0b, 0c, 0d를 메모리에 저장해야한다.

        - 이때 하위 바이트를 먼저 메모리에 기록하는 방식이다.

        - 낮은 주소에 하위 바이트가 기록되고, 높은 주소에는 상위 바이트가 기록된다.

  - 접미사들

    - ldrb, strb

      - zero-extended byte를 읽고 저장한다.

      - 제로 확장은 옮길 바이트를 제외한 값을 0으로 채운다.

    - ldrh, strh

      - 제로 확장된 half-word(=16bit)를 읽고 저장한다.

    - ldrsb, strsb

      - 사인 확장된 바이트를 읽고 저장한다.

      - 사인 확장은 사인 비트(MSB[31])를 복제해서 채운다.

    - ldrsh, strsh

      - 사인 확장된 하프 워드를 읽고 저장한다.

    - 이러한 확장은 정보의 의미를 변화시키지 않는 선에서 편한대로 사용하면 된다.

      - 그러나 Alignment restriction에 의해 메모리 접근은 워드 단위로 하는 것이 옳다.

- Multiple Register Transfer

  - Multiple Access = Stack을 위한 명령어 들이다.

    - 함수를 호출할 때, 레지스터의 값들을 기록해놓기 위해 사용한다.

  - LDM(load multiple)

    - 스택에 있는 값들을 {}안의 레지스터 목록들에 불러온다.

    ```
    ldm sp!, {r0, r1, r2, r3}   ; sp에서 r0, r1, r2, r3에 값을 불러온다.

    ldm sp!, {r0-r3} ; 위와 똑같은 기능을 한다.
    ```

  - stm(store multiple)

    - 스택 포인터(r13)에 레지스터 목록들을 저장한다.

    ```
    stm r13(=sp)!, {r0, r1, r3, r6, r11}
    ```

    - opcode의 [15:0] 비트가 각 레지스터가 입력됐는지 여부를 저장한다.

      - r0가 입력되었으면, [0] = 1이 된다.

      - r6가 입력되었으면, [5] = 1이 된다.

      - 따라서 괄호 내부 레지스터의 순서는 관계가 없다.

    - 이 값에 따라 sp(=r13)에 레지스터의 값들을 저장해나간다.

      - 낮은 레지스터는 낮은 메모리 주소에,

      - 높은 레지스터는 높은 메모리 주소에 저장된다.

    - 접미사 !를 통해 addressing mode를 지정할 수 있다.

      - IA(Increment after)

        - r13에 저장하고, r13을 4 증가시킨다.

      - IB(Increment before)

        - r13를 4 증가시키고, r13에 저장한다.

      - DA(Decrement after)

        - r13에 저장하고, r13를 4 감소시킨다.

      - DB(Decrement before)

        - r13을 4 감소시키고, r13에 저장한다.

    - 일반적으로 sp(=r13)은 스택의 꼭대기(뚜껑?)를 가리키고 있다.

      - strdb를 통해 스택에 저장하고,

      - ldmia를 통해 스택에서 읽어오는게 국룰이다.

    - 스택 연산의 의사 명령어

      - F = full, sp가 제일 최근에 들어온 데이터를 가리켜야함.

      - E = Empty, sp가 다음 데이터가 들어올 장소를 가리켜야함.

      - D = Descending

      - A = Aescending

      - ARM에서는 기본적으로 FD(Full Descending) 스택을 사용하고 있다.

        - 따라서 stmfd, ldmfd로 복잡한 것 없이 스택을 사용할 수 있다.

        - 이는 stmdb, ldmia과 완전히 동일한 기능을 한다.
