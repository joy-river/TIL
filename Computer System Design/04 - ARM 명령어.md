### 데이터 처리 명령어
---
# ADD, ADC
---
* ADD는 단순한 덧셈을 계산한다.

    ```
    add r0, r1, #12 ; (r0 = r1 + 12)
    
    adds r0, r1, #30 ; add의 결과로 CPSR을 업데이트 한다

    cmp r1, r2
    addgt r0, r1, r2 ; r1와 r2를 비교해서, r1이 더 크면 add를 수행하고 아니면 무시한다.
    ```

* ADC(ADD with carry)는 C 플래그와 함께 덧셈을 수행한다.

    * 이를 통해 32비트를 초과하는 덧셈도 가능하다!

    ```
    64비트 상수를 두 레지스터로 표현한다.
    rn = r5 and r4
    rm = r9 and r8

    adds r0, r4, r8
    adcs r1, r5, r9
    ```
                
# SUB, SBC
---
* SUB는 뺄셈을 수행한다.

    * 사실상 2의 보수를 통한 덧셈을 실행한다.

* SBC는 두 연산자를 C 비트와 함께 뺀다

    * 32비트 초과 뺄셈도 가능하다!

# CLZ
---
* CLZ(Count Leading Zero)는 1 값을 가진 비트가 나올 때 까지 몇 개의 0비트가 나왔는지 계산한다.

    ```
    r0 = 0x0000_0001_0000_....
    
    clz r1, r0      ; r1에 7이 기록된다
    ```
    * 당연히 MSB가 1이면 0을 반환한다.

# AND, ORR, EOR, BIC
---
* 논리적인 연산 and, or, xor을 수행한다.

    ```
    eor r0, r0, r0은 ; r0을 모두 0으로 만든다
    bic r0, r0, r1   ; r0에서 r1에 있는 값은 모두 없앤다.
    ```

# CMP
---
* 두 레지스터 값을 비교할 때 사용한다.

    * V 플래그를 제외한 N, Z, C 플래그가 업데이트된다.

* CMP는 r0 - r1으로 비교한다.

* CMN은 r0 - (-r1)으로 비교한다.

* TST는 r0 and r1으로 비교한다.

* TEQ는 r0 xor r1으로 비교한다.


### Branch Instruction
---
# B, BL
---
* B는 특정 라벨(Label)로 브랜치 한다

    ```
    b foo       ; foo로 브랜치 한다.
    ```
    * 브랜치는 pc를 다른 메모리 주소를 가리키게끔 덮어쓰는 것이다.

        * 라벨이 바로 다른 메모리 주소를 의미한다.

        * Execution flow를 바꾼다.

    * 브랜치에도 접미사를 붙일 수 있다.

* BL은 특정 라벨로 분기하나, r14(=Link register)에 돌아올 메모리 주소를 저장해놓는다.

    * L 비트를 따로 사용하며, L이 1인 경우 lr에 주소를 저장한다.

    * 만약 함수 내부에서 다시 한 번 BL을 호출하면 lr값이 덮어씌워져 원래 위치로 돌아오지 못할 수도 있다.