### ARM PROCESSER
--- 
* ARM 프로세서의 가장 큰 특징은
**32-bit ISA**(Instruction Set Architecture)를 사용한다는 것.

* ARM은 RISC 기반이므로 명령어가 단순한 작업만을 수행하며, 명령어가 획일화 된 길이(32bit)를 가지게 된다.

* x86은 CISC 기반이므로 한 명령어가 여러 복잡한 작업을 수행하며, 명령어가 다양한 길이로 존재할 수 있다.

    * ex) push = 1byte, mov = 2byte, sub = 3byte

* ARM에는 여러 종류의 **아키텍쳐**(Architecture)가 존재하고,
이를 구현한 것이 우리가 **프로세서**(Processor)라고 부르는 것이다.

>수업에서는 ARMv7을 구현한 Cortex-A9 프로세서를 사용하게 된다.

* ARM6에서는 1.2μm의 세미컨덕터(SemiConductor)를 사용했음.

* 세미 컨덕터란 트랜지스터(Transistor)라고 봐도 무방.

* 2023년도 기준 대략 3nm 길이까지 축소 되었다


### Abstraction(추상화)
---
* 추상화는 복잡한 기능을 다룰 때 도움을 주는 것으로써, low-level의  상세한 내용까지 알 필요 없게끔 한다.

* 여기서 중요하게 여겨지는 것이 바로 *ISA*이다.

>*ISA = Instruction Set Architecture.*  
하드웨어와 low-level의 소프트웨어 사이를 이어주는 인터페이스의 역할을 한다.

* 컴퓨터는 두개의 추상화 계층(Abstraction layer)이 존재한다.

* CPU가 제공하는 ISA를 통해 Machine Language와 Assembly Language로 하드웨어와 소통하는 계층
* 그리고 OS가 제공하는 추상화 계층이 있다.

* 이를 통해 사용자는 제공되는 API로 응용프로그램을 만들 수 있게 된다.

* 고급 언어를 컴파일하면 어셈블리어가, 어셈블리어는 어셈블러를 거쳐 최종적으로 기계어로 바뀌게 된다.



### A Memory Hierarchy(메모리 계층)
---
>프로세서 <-> 메인 메모리(DRAM) <-> 스토리지(Storage)

* 프로세서에는 RegFile 이라고 부르는 레지스터들이 존재하며, 이 수업에선 이를 중점적으로 다루게 됨.

* 프로세서와 메인 메모리 사이에는 여러 종류의 *캐시(Cache)* 가 존재함

    * 캐시가 작은 여러 개로 나뉘어져 있는 이유는 한 캐시만 존재할 경우 액세스 타임이 너무 길기 때문

    * 대략 30 clock cycle 이상을 cpu가 기다리게 됨

* 내가 만들어낸 프로그램은 메인 메모리에 로드 되어있으며, 이는 Data와 Code로 나뉘어져있다.

    * 코드는 단순한 명령어들의 집합

* CPU가 데이터를 코드에 맞게 처리하려면

1. 메인 메모리의 데이터를 Regfile에 불러오고

2. ALU에서 이를 처리한 후 

3. 다시 regfile에 결과를 저장

4. 이 결과를 메인 메모리에 보내는 과정을 거쳐야 한다.

* 이 작업을 위해 CPU는 굉장히 많은 명령어를 제공함(약 200개 이상)... 그럼 이거 다 외워야됨? 그건 아님.

* 모든 CPU는 3가지 카테고리의 명령어를 제공해 준다.

1. **데이터 처리 명령어(Data Processing Instuctions)**

    * 수리(Arithmatic)와 논리(Logical) 연산을 위한 명령어.

    * 4Ghz cpu면 0.25ns마다 한개씩 1초에 총 $4*10^9$ 개의 데이터를 처리할 수 있음.

2. **메모리 접근 명령어(Memory Access Instructions)**

    * 불러오기(Load)와 저장(Store)를 위한 명령어.

3. **분기 명령어(Branch Instructions)**

    * 조건에 따른 분기(if, conditional) 명령어.

* 컴파일러는 이 세가지 명령어 종류를 통해 고급 코드를 -> binary(이진) 코드로 변환해 줌.



### ARM Registers
---
* ARM 프로세서에서 레지스터의 종류는 총 31개가 존재함.

    * 이 레지스터들은 범용 목적 레지스터(General Purpose Register)라고 부름.

* 레지스터는 프로세서가 어떤 모드(Mode)에 들어와있는지에 따라 약간씩 다른 레지스터를 사용하게 된다.

* 모든 모드에서 레지스터는 총 16개 사용하게 되며, 이를 r0 ~ r15라고 칭한다.

> 각 레지스터는 32bit = 4byte의 크기를 가진다. 따라서 프로세서는 총 64바이트를 사용할 수 있다.

* r13 ~ r15 레지스터는 spr(Special Purpose Register)라고도 부른다.

* r13 레지스터는 **sp(Stack Pointer)** 라고 부르며, 스택이라는 메모리 주소를 사용할 때 스택의 가장 위 주소를 저장한다.

    * 스택을 사용하려면 sp를 항상 초기화(Initialize)해야함.

* r14 레지스터는 **lr(Link Register)** 라고 부르며, 분기점과 만났을 때 분기 후 돌아올 메모리 주소를 기록한다.

* r15 레지스터는 **pc(Program Counter)** 라고 부르며, 컴퓨터에 전원을 넣었을 때 가장 먼저 실행될 명령어의 메모리 주소를 기록한다.

    * 이 주소는 CPU 제작자가 임의로 설정한다.

        * ARM에서는 주소가 0을 기록하고 있다.

        * 인텔에선 0xFFFF_FFF0를 기록한다.

    * 첫 명령어가 실행된 후에는 다음 실행되어야 할 명령어의 주소로 바꿔 기록된다.

        * Jump로 분기했다면 Jump 된 후의 주소를 기록하는 식이다.

    * 어떤 모드에서도 동일한 pc를 사용한다.

* CPU는 여러 Operating Mode가 있으며, ARM에서는 총 9개의 모드가 존재한다.

* 각 모드에 따라 사용되는(매핑되는) 레지스터는 조금씩 다르다.

    * 이 레지스터들은 칩 내부에 물리적으로 분리되어있는 레지스터다.
    
    * r0 ~ r7은 모든 모드에서 동일하게 사용되는 Unbanked 레지스터이다.
    * r8 ~ r14는 모드마다 약간씩 다르게 사용되는 Banked 레지스터이다.
    
    * r13(sp)와 r14(lr)는 거의 모든 모드에서 다른 레지스터를 사용한다.

