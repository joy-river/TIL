### ARM Instruction
---
* Rm = Second src operator를 잘 기억해두자.

    * Rm은 시프트 연산과 함께 묶여서 12개의 비트 N으로 표기한다.

# Data Processing Instruction

### Move Instruction
---
* Rn없이 Rm만 가지고 있다.

* 실제로 값을 옮기는게 아니라, 레지스터의 값을 복사한다.

    ```
    mov r0, r2 ASR #5 ; r0에 r2의 값을 5번 시프트, 복사(r0 = r2 / 32)

    mov r0, r1        ; r0에 r1값을 복사

    mov r0, r0        ; no effect == nop

    mov r0, r0, LSL#3 ; r0 = r0 * 8

    mov pc, r14       ; (r14 = link register) caller로 돌아간다.(함수)

    movs pc, r14; pc <- r14(lr), CPSR <- SPSR; 
    Used to return from interrupt or exception.

    ```
    * pc는 읽어야할 명령어의 주소를 담고 있으므로, 아주 조심히 접근해야한다.

    * S 접미사가 붙으면 CPSR을 업데이트한다.

        * S 접미사는 모든 데이터 처리 명령어에 붙일 수 있다.

* Immediate Constant(즉시 값)

    * 메모리를 읽을 필요없이 명령어에서 즉시 사용할 수 있는 값

    * ARM은 32비트 입력 상수를 표현할 수 없음

        * 상수 값은 N의 12비트 속에 저장되기 때문에

    * 따라서 N의 12개의 비트 중 상위 4비트는 회전(로테이트) 양의 1/2를 기록하고, 하위 8비트는 상수를 기록하는 간접적인 방법을 쓴다.

        * 8비트 상수는 배럴 시프터로, 4비트 회전(로테이트) 양은 왼쪽으로 1번 시프트하여( * 2) 시프터에 넣어준다.

        ```
        mov r0, #0x12   ; r0에 16진수 12를 넣겠다. 이는 8비트로 충분하다.
        ```

        * 기계어로는 012로 표현된다. 0 = no shift, 12 = constant

        ```
        mov r0, #0x1200 ; r0에 16진수 1200를 넣겠다. 이는 16비트 이므로 시프트가 필요하다.
        ```

        * 기계어로 살펴보자. #0000_0012 = no shift
        * 8비트 로테이트시 = #1200_0000
        * 16비트 로테이트 =  #0012_0000
        * 24비트 로테이트 =  #0000_1200

        * 따라서 #0x0000_1200을 만들기 위해서는 기본 값 #0x12에서 24비트를 로테이트 시키면 된다.

            * 24비트를 로테이트 시키려면 그 절반인 12를 기록한다

        * 따라서 12는 c가 되어 N비트는 0xc12가 된다.

        * 만약 #0x1234_5678 같은 값을 입력하려고 시도하면, 컴파일러가 거부할 것이다.(굳이 고려하지 않아도 괜찮다.)

    * 그러면 큰 상수는 사용할 수 없는 것인가?

        * ldr 명령어를 사용할 수 있다.

        ```
        ldr r0, =0x55555555 -> ldr r0, [PC, #imm12]
        ```

        * 사용할 상수 값을 입력하면, 컴파일러가 이 상수가 저장되어있는 메모리 주소를 찾아낸다.

### 플래그(Flags)
---
* 한 번 언급했으나, 다시 한 번 훑어보자.

    > N(Negative)
    
    * ALU output Rd[31:0]의 MSB인 Rd[31]이 N 플래그가 된다.

        * 즉 sign bit에 따라 업데이트 된다.

    * 컴퓨터는 2의 보수(two's complement)를 사용하여 음수를 표현한다.

        * -1 을 표현하고 싶다면.

            1. +1 = 0x0000_0001을 준비한다.

            2. +1의 모든 비트를 반전한다 = 0xffff_fffe

            3. 거기에 1을 더한다 = 0xffff_ffff = -1

        * 그런데 0xffff_ffff는 $2^32 -1$ 일 수도 있다.

        * 하지만 두 경우 다 N 플래그는 1이 된다.

    * 음수인지 큰 양수인지 결정하는 것은 N 플래그가 아니며, N 플래그를 어떻게 해석할 것인지는 프로그래머가 결정한다.

    > Z(Zero)
    
    * ALU output Rd = 0 일 때 세트된다.

        * 비트들을 전부 or 게이트에 집어넣고 전체를 not 하면 된다.

    > C(Carry)

    * 마지막으로 Carryout된 비트(C31 = 31번째 비트에서 발생한 초과)가 C 플래그가 된다.

        * 뺄셈에서 Borrow가 발생하지 않아도 세트된다.

    * C 플래그는 Unsigned Integer를 비교하는데 사용한다.

        1. a, b를 비교한다면, a - b의 크기를 계산한다.

        2. a - b = a + (-b)이다.

        3. a + ~b + 1 로 표현할 수 있다.

        4. 만약 a >= b라면, a + ~b + 1은 무조건 31비트를 초과하므로, C 비트가 세트된다.

    * 논리연산에서도 배럴 시프터의 결과에 따라 N, Z, C 플래그가 세트될 수 있다.
    
    > V(oVerflow)

    * 굉장히 중요한 플래그이며, C31 xor C30으로 계산할 수 있다.

    * V 플래그는 Signed Integer를 비교하는데 사용한다.

        * Signed Integer 사이에서 오버플로우가 발생하면, V 플래그가 세트된다

    * V 플래그는 논리 연산에서는 손대지 않는다.
    