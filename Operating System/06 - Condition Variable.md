### Condition Variable

---

- Condition Variable(조건 변수)는 스레드가 실행을 지속하기 전에 특정 조건이 만족되었는지 체크할 때 사용한다.

  - ex.부모 스레드가 자식 스레드의 상태를 체크하는 경우 (join())

  - 자식 스레드가 실행 완료될 때 까지 spin하는 것은 손해가 크다.

- 조건 변수는 스레드들의 큐(Queue of threads)로써, 특정 조건에 따라 큐에 저장되거나 깨워진다.

  > Waiting

  - 실행이 요구되지 않는 조건에서 스스로 큐에 들어가 대기한다.

  > Signaling

  - 특정 스레드는 조건에 따라 다른 스레드를 깨워 마저 실행되게 만든다.

- 조건 변수는 세 가지 요소를 하나로 묶어 구현한다.

  1. condition variable c

  2. state variable m

  3. lock L // m을 보호하기 위한 락이다.

- POSIX에서는 다음과 같이 정의되어있다.

  - Pthread_cond_t c = PTHREAD_COND_INITIALIZER;

  - Pthread_cond_wait(Pthread_cond_t *c, Pthread_mutex_t *m)

    - wait 함수는 뮤텍스를 독립변수로 받는데, wait하는 스레드는 락을 해제하고, 후에 깨워지는 경우에 다시 획득해야하기 때문이다.

  - Pthread_cond_signal(Pthread_cond_t \*c)

- 조건 변수를 사용한 부모 자식 스레드의 실행을 살펴보자.

  - 부모 스레드는 thr_join() 함수를 호출한다.

    1. 락을 획득한다.

    2. 자식 스레드가 실행 완료되었는지 반복적으로 체크한다. (while(done == 0))

    3. 만약 실행이 완료되지 않았으면, 락을 해제하고 잠든다.

    4. 자식의 실행이 완료되면 깨어나 실행을 마저 완료하고 락을 해제한다.

  - 자식 스레드는 자신의 일을 마친 후 thr_exit() 함수를 호출한다.

    1. 락을 얻는다.

    2. 상태 변수 done을 1로 만든다.

    3. 부모에게 signal하여 부모 스레드를 깨운다.

    4. 락을 해제한다.

- 상태 변수는 왜 필요한가? 왜 반복적으로 체크해야하는가?

  - 비결정적 시스템은 스레드의 실행 순서가 언제든 뒤바뀔 수 있다.

    - 만약 자식 스레드가 순간적으로 실행되어, 부모의 join()보다 exit()이 먼저 호출될 경우

    > 부모에게 signal을 보내지만, 부모는 아직 sleep상태가 아니다!

  - 상태 변수를 특정 시점에만 체크하는 경우 경쟁 상태가 발생할 수 있다.

    - 만약 부모가 done == 0임을 확인하고 잠들기 직전, 인터럽트에 의해 중단된다고 가정하자.

    - 자식 스레드는 done을 1로 바꾸고 부모에게 signal을 보낼 것이다.

    > 부모는 signal을 받은 후에 sleep하게 될 것이고, 영면에 빠지게 될 것이다!

### Producer / Consumer Problem

---

- 동시성 문제 중 하나인 Producer / Consumer (Bound buffer)문제를 알아보고 해결해보자.

  - Producer는 버퍼가 비어있으면 데이터를 put()으로 저장한다.

    - 만약 버퍼가 차 있으면 대기한다.

  - Consumer는 버퍼가 꽉 차 있으면 데이터를 get()으로 가져온다.

    - 만약 버퍼가 비어있으면 대기한다.

  - HTTP 요청을 주고받은 웹 서버가 이 모델에 대응한다고 볼 수 있다.

- 이 문제를 하나의 조건 변수와 락을 가지고 해결할 수 있겠다.

  - 조건 변수 cond는 Producer와 Consumer를 대기시키고 깨우는 역할을 한다.

  - 상태 변수 count는 버퍼가 비었는지, 꽉 차 있는지를 알려주는 역할을 한다.

  - 락을 통해 cs에 접근할 수 있게 된다.

- 그런데 만약 다수의 Producer와 Consumer가 있는 경우는 어떨까?

  > p1, c1, c2가 있다고 가정하자.

  1. c1은 버퍼가 비어있음을 확인하고, 잠들었다.

  2. p1은 버퍼가 비어있어 데이터를 채워넣고, c1에게 신호한다.

  3. c1이 신호를 받기 전에, c2가 등장해 버퍼에서 데이터를 받아갔다.

  4. 뒤늦게 도착한 c1은 이미 비어버린 버퍼에 접근한다.

- 이런 문제는 아주 간단한 현상에 의해 발생한다.

  > Mesa semantics = 스레드가 깨어났을 때, 원하던 상태가 그대로 유지되고 있다고 보장하지 않는다.

  - 그 반대의 개념은 Hoare semantics라고 칭하나, 현재 대부분의 시스템은 Mesa semantics를 사용한다.

- 이를 해결하기 위해선, 깨어난 스레드가 다시 한번 상태를 체크해야한다.

  - 따라서 조건 변수를 사용할 때 항상 if가 아닌 while을 사용하도록 해라.

- 그런데 또 다른 문제가 있다.

  - 우리는 P -> C, C -> P로 signal이 이루어질 것이라고 생각한다.

  - 실제로는 P -> P, C -> C로의 signal이 생겨날 가능성도 존재한다.

  - Producer와 Consumer가 같은 큐에서 대기하고, 같은 큐에 신호를 보내기 때문에 신호가 의도와 다르게 전달될 수 있다.

- 이를 해결하기 위해서는 두 개의 조건 변수를 사용해야 한다.

  - Producer는 empty 조건 변수에서 대기하고, fill에 신호한다.

  - Consumer는 fill 조건 변수에서 대기하고, empty에 신호한다.

- 최종적으로 동시성과 효율성을 올리기 위해 버퍼를 배열로 만들어 더 많은 슬롯을 제공할 수도 있다.
