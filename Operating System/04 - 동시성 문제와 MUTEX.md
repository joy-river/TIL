### Concurrency(동시성)
---
* 우리는 스레드에서 동시성이라는 특징을 볼 수 있다.

    * 두 개 이상, 여러 스레드가 병렬(Parallel)하게 실행된다.

    * 이런 스레드들이 여러 변수를 공유하게 된다.

    * 이 스레드 간 상대적인 실행 속도(순서)를 예측할 수 없다.

* 그럼 이게 뭐가 문제냐? -> 비결정성(Non-Determinism)을 낳는다.

    * 비결정성이란, 프로그램을 실행할 때 마다 결과가 달라지는 것.

        * 프로그램의 결과가 스레드들의 실행 순서에 따라 매번 달라지게 된다.

        * 여기서 나오는 문제가 바로 경쟁 상태 문제이다!

### 경쟁 상태 문제(Race Condition Problem)
---
* 만약 여러 스레드가 공유하는 자원에 동시에 접근하려고 하면 문제가 발생한다.

    * 스레드들이 접근하는 순서에 따라 프로그램의 결과가 달라지고 만다!

    * 이때 경쟁 상태를 일으키는 코드, 데이터를 임계 구역(Critical Section, cs)이라고 한다.

* 이를 해결하기 위해서는 스레드들의 실행 순서를 확정지어줘야 한다!

    > 이를 스레드간의 상호 배제(Mutual Exclution)이라고 칭한다.

    * 한 스레드가 cs에 접근하면, 다른 스레드는 cs에 접근하지 못하게 방지해야한다.

### 상호 배제(Mutual Exclusion)
---
* 상호 배제는 3가지 조건을 충족해야한다.

    1. 다수의 스레드가 cs에 접근할 수 없다(실행할 수 없다.)

    2. cs 밖의 스레드는 cs 안의 스레드에 영향을 미칠 수 없다.

    3. cs에 접근하기 위해서 무한정 대기하지는 않는다.

* 이를 구현하기 위해 OS가 locks라는 Preemtive(선점)을 제공한다.

    * locks란 일종의 데이터 타입, 객체나 변수이다.

    * cs에 진입하려는 스레드는 무조건 lock을 얻어야한다. 얻지 못하면 대기한다.

    * cs에서 빠져나갈 때는 lock을 내려놓는다.

* 따라서 cs 내부의 각각의 데이터는 자신만의 lock을 가지고 있다.

### MUTEX(Mutual Exclusion Locks)
---
* 상호 배제를 구현하기 위해 두 가지 상태를 가지는 객체를 구현한다.

    * set(Locked)과 free(Unlocked) 상태를 가진다.

    * binary하게 0, 1로 구현할 수 있다.

* Mutex를 위해서는 두 명령어가 필요하다.

    * Lock 명령어는 lock이 free 상태면 얻는다, 아니라면 대기한다.

    * Unlock 명령어는 가진 lock을 free하게 만들고, lock을 대기하고 있는 스레드 중 하나를 깨운다.

* cs에 접근하기 전에 Lock을, 접근 후에 Unlock을 호출하여 Mutex를 구현할 수 있다.

### 뮤텍스의 구현법
---
* 그럼 실제로 뮤텍스를 구현해보자.

    * 뮤텍스의 두 명령어는 무조건 atomic해야한다.(싱글 사이클, 하나의 명령어로 실행되어야한다.)

        * 다른 명령어로 쪼개지지 않아야한다(또 다른 경쟁상태를 유발할 수 있다.)

    * 이를 위해서는 하드웨어적인 지원이 필요하다.

        * cpu가 특별한 명령어를 제공한다.

        * Atomic test, set이나

        * Atomic compare, swap/exchange 등을 제공한다.


* Test and Set Lock(TSL) 명령어

    * lock을 하나의 word로 잡는다.

        * 0 = not locked.
        * 1 = locked.

    * 다음과 같은 것들을 Atomic하게
