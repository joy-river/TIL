### Concurrency(동시성)

---

- 우리는 스레드에서 동시성이라는 특징을 볼 수 있다.

  - 두 개 이상, 여러 스레드가 병렬(Parallel)하게 실행된다.

  - 이런 스레드들이 여러 변수를 공유하게 된다.

  - 이 스레드 간 상대적인 실행 속도(순서)를 예측할 수 없다.

- 그럼 이게 뭐가 문제냐? -> 비결정성(Non-Determinism)을 낳는다.

  - 비결정성이란, 프로그램을 실행할 때 마다 결과가 달라지는 것.

    - 프로그램의 결과가 스레드들의 실행 순서에 따라 매번 달라지게 된다.

    - 여기서 나오는 문제가 바로 경쟁 상태 문제이다!

### 경쟁 상태 문제(Race Condition Problem)

---

- 만약 여러 스레드가 공유하는 자원에 동시에 접근하려고 하면 문제가 발생한다.

  - 스레드들이 접근하는 순서에 따라 프로그램의 결과가 달라지고 만다!

  - 이때 경쟁 상태를 일으키는 코드, 데이터를 임계 구역(Critical Section, cs)이라고 한다.

- 이를 해결하기 위해서는 스레드들의 실행 순서를 확정지어줘야 한다!

  > 이를 스레드간의 상호 배제(Mutual Exclusion)이라고 칭한다.

  - 한 스레드가 cs에 접근하면, 다른 스레드는 cs에 접근하지 못하게 방지해야한다.

### 상호 배제(Mutual Exclusion)

---

- 상호 배제는 3가지 조건을 충족해야한다.

  1. 다수의 스레드가 cs에 접근할 수 없다(실행할 수 없다.)

  2. cs 밖의 스레드는 cs 안의 스레드에 영향을 미칠 수 없다.

  3. cs에 접근하기 위해서 무한정 대기하지는 않는다.

- 이를 구현하기 위해 OS가 locks라는 primitives(기본 형식)을 제공한다.

  - locks란 일종의 데이터 타입, 객체나 변수이다.

  - cs에 진입하려는 스레드는 무조건 lock을 얻어야한다. 얻지 못하면 대기한다.

  - cs에서 빠져나갈 때는 lock을 내려놓는다.

- 따라서 cs 내부의 각각의 데이터는 자신만의 lock을 가지고 있다.

### MUTEX(Mutual Exclusion Locks)

---

- 상호 배제를 구현하기 위해 두 가지 상태를 가지는 객체를 구현한다.

  - set(Locked)과 free(Unlocked) 상태를 가진다.

  - binary하게 0, 1로 구현할 수 있다.

- Mutex를 위해서는 두 명령어가 필요하다.

  - Lock 명령어는 lock이 free 상태면 얻는다, 아니라면 대기한다.

  - Unlock 명령어는 가진 lock을 free하게 만들고, lock을 대기하고 있는 스레드 중 하나를 깨운다.

- cs에 접근하기 전에 Lock을, 접근 후에 Unlock을 호출하여 Mutex를 구현할 수 있다.

### 뮤텍스의 구현법

---

- 그럼 실제로 뮤텍스를 구현해보자.

  - 뮤텍스의 두 명령어는 무조건 atomic해야한다.(싱글 사이클, 하나의 명령어로 실행되어야한다.)

    - 다른 명령어로 쪼개지지 않아야한다(또 다른 경쟁상태를 유발할 수 있다.)

  - 이를 위해서는 하드웨어적인 지원이 필요하다.

    - cpu가 특별한 명령어를 제공한다.

    - Atomic test, set이나

    - Atomic compare, swap/exchange 등을 제공한다.

- Test and Set Lock(TSL) 명령어

  - lock을 하나의 word로 잡는다.

    - 0 = not locked.
    - 1 = locked.

  - 다음과 같은 것들을 Atomic하게 실행한다.

    - Atomic하다는 것은 하나의 명령어를 cpu의 한 사이클 내에 실행한다는 것이다.

      1. old value를 가져온다.

      2. 락을 true로 세트한다.

      3. old value를 반환한다.

    - 만약 반환된 값이 False면

      - 락을 획득한다!

    - 만약 반환 값이 true면

      - 다른 스레드가 이미 락을 가지고 있다. 다음 기회를 노린다.

  - TSL은 락을 얻기 위해서 사용하는 명령어이다.

    - 락은 이진 변수이므로 값을 0으로 바꾸기만 하면 락을 해제할 수 있다.

  - 여기서 발생하는 문제 중 하나가 바로 바쁜 대기(Busy Waiting)이다.

### Busy Waiting(바쁜 대기)

---

- TSL은 락을 얻을 수 있을 때 까지 계속해서 Test를 반복한다.

  - 즉, 락을 얻지 못한 스레드는 계속해서 Test를 반복하며, cpu를 점유하게 된다.

  - 이러한 대기상태를 바쁜 대기라고 하며, Polling 혹은 Spinning이라고도 표현한다.

  - TSL을 통한 락의 구현은 바쁜 대기를 일으키며, spin lock이라고 한다.

- 이는 효율적이지 못한 구현 방식이다.

  - 스레드가 cpu를 계속 점유하므로 다른 스레드는 cpu를 사용할 수 없다.

  - 교착상태(Deadlock)을 일으킬 수 없다.

- 그럼 바쁜 대기를 일으키지 않는 방식은 없을까?

  > Blocking = 락을 얻지 못한 스레드를 잠들게(Blocked) 만들자.

  - Sleep을 통해 락을 가지지 못한 스레드를 잠들게 만든다.

    - 스레드는 Blocked 된다.

  - wakeup을 통해 스레드가 락을 내려놓을 때 잠든 스레드 중 하나를 깨워 락을 얻게 만들자.

    - 스레드는 Ready 혹은 Running 상태가 된다.
