### Scheduling(스케줄링)

---

- 스케줄링은 OS의 일부인 Scheduler(스케줄러)가 결정하는 작업이다.

  - 이때 스케줄링 알고리즘을 사용한다.

- 스케줄러는 문맥 교환(Context Switching)이 일어날 때 호출된다.

  - 문맥 교환은 다음 경우에 발생한다.

    - 프로세스의 생성과 소멸

    - IO 입력을 기다리며 프로세스가 block됨

    - IO 인터럽트의 발생

    - 타이머 인터럽트의 발생

  - 따라서 문맥 교화은 스케줄러를 호출하는 함수라고도 볼 수 있다.

- 우리에겐 크게 두 타입의 프로세스가 있다.

  > IO bound Process

  - 대부분의 프로세스이며, 사용자와 상호 소통이 가능하다.

  - 짧은 프로세스(Short process)라고도 칭하며, 일반적으로 cpu를 오래 점유하지 않는다.

  > CPU bound Process

  - 사용자와 상호 소통하지 않는 프로세스이다.

  - 긴 프로세스(Long process)라고 하며, 일반적으로 오래 cpu를 점유하는 특징을 지닌다.

- 이 프로세스들이 실행하는 작업량(Workload)은 각양각색이므로, 일반화를 위해 가정을 추가하자.

  - 각 작업은 똑같은 양의 시간동안 실행된다.

  - 모든 작업은 동시에 도착(Arrive)한다.

  - 모든 작업은 CPU만 사용한다 = CPU bound Process이다.

  - 각 작업의 run-time(실행 시간)이 알려져있다.

- 이 가정들은 비현실적이지만, 한개씩 완화해 나갈 것이다.

### Scheduling Metrics

---

- 스케줄링을 평가할 기준, 단위를 만들자. 처음 두가지는 다음과 같다.

  - Turnaround time(Performance metric)

    - 반환 시간은 어떤 프로세스가 완료될 때까지 걸린 시간이다.

    > $T_{turnaround} = T_{completion} - T_{arrival}$

  - Fairness

    - 모든 프로세스가 cpu를 차지할 공평한 기회를 가지는지 여부이다.

- 가장 단순한 스케줄링 알고리즘 FIFO를 평가한다.

  - FCFS(First Come, First Served)라고도 하며, 먼저 도착한 작업을 먼저 처리한다.

    - 가장 단순하고 쉽게 구현가능하다.

  - 각 작업이 거의 동시에 도착하고, 10초가 걸린다고 가정하자.

    > Avg turnaround = (10 + 20 + 30) / 3 = 20 sec
  
  - 문제는 Convey effect이다.

    - 가정 1을 완화해서, 모든 작업이 똑같은 시간동안 실행되지 않는다고 한다면?

    - 첫 작업이 오랜 시간 실행되는 경우, 뒤에서 대기하는 작업들의 반환시간은 한없이 증가한다.

      - avg turnaround가 증가하게된다!

- 오케이 그럼 실행 순서가 짧은 거 부터 실행하자(SJF)

  - Shortest Job First로, 가장 짧은 작업부터 먼저 처리하는 비선점형(Non-Preemptive) 스케줄러이다.

    - 비선점이란, 프로세스가 스스로 종료하기 전에 cpu를 압수하지 않는다는 뜻이다.

    - 즉, 우선순위를 가지고 실행중인 프로세스를 변경하지 않는다.

  - 모든 작업이 동시에 도착했을 때, 가장 짧은거부터 실행하면, avg turnaround를 줄일 수 있다.

  - 그러면 가정 2, 모든 작업이 동시에 도착하지 않는다고 한다면?

    - 긴 작업이 먼저 도착하고, 짧은 작업이 늦게 도착하면 FIFO와 다를게 없어진다.

  - 한번 프로세스가 실행되면, 더 짧은 작업이 도착해도 바꿀 수 없다는게 문제다.

- STCF(Shortest Time-to-Completion First)

  - SJF에 Preemption을 더한 스케줄러 이다. (PSJF라고도 한다)

  - 새로운 작업이 도착하면, 스케줄러가 현재 실행중인 작업과 새로운 작업을 비교한다.

  - 더 짧게 끝나는 쪽을 실행시킨다.

  - 여기서 새로운 평가기준을 도입하자

  - Response time(반응성)

    > $T_{response} = T_{firstrun} - T_{arrival}

    - STCF는 긴 작업이 다른 모든 짧은 작업이 실행되길 기다려야하므로, 반응성면에서는 좋지 못하다.

- RR(Round Robin)

  - Time Slice 알고리즘이라고 볼 수 있다.

    - 특정 시간 동안 작업을 실행시키고, 다음 작업으로 교체한다.

    - time slice = scheduling quantum = 100ms

      - time slice는 타이머 인터럽트 주기의 배수여야한다.

      - 타이머 인터럽트는 일반적으로 1ms 주기를 갖는다.

  - 이를 통해 RR은 Fairness와 response time 면에서 좋은 평가를 가진다.

  - 하지만 Turnaround 면에서는 뛰어나지 못하다. (작업 완료에 너무 오랜 시간이 걸릴 수 있다.)

  - time slice가 짧을 수록

    - 반응성이 뛰어나다.

    - 문맥 교환이 자주 일어나므로, 문맥 교환에 드는 비용이 전체적인 성능을 결정한다.

  - time slice가 길 수록

    - 문맥 교환에 드는 비용을 절감할 수 있다.

    - 대신에 반응성이 나빠질 것이다.

  - 이제 가정 3, 프로세스들이 IO까지 사용한다고 가정하자.

    - cpu만 사용할 수도 있지만, cpu는 조금 사용하고 IO에 시간을 쓸 수도 있다.

    - IO를 기다리는 동안에 cpu를 놀게하는건 손해이므로, 다른 프로세스가 cpu를 사용할 수 있게 하자.

    - 어떤 작업이 IO 요청을 시작하면

      - 작업은 IO가 완료될 때 까지 Blocked된다.

      - 스케줄러는 cpu에 다른 작업을 할당한다.

    - IO가 끝나면

      - 인터럽트가 발생한다.

      - 프로세스가 blocked에서 ready가 된다.

- Multi-Level Feedback Queue(MLFQ)

  - 과거에서 학습해서 미래를 예측하는 알고리즘이다.

  - 목표

    - turnaround time을 최소화한다 = 짧은 작업을 먼저 실행한다.

    - response time을 최소화한다 = 작업 길이에 대한 사전 지식 없이.

  - MLFQ는 구분되는 여러 개의 큐를 가진다.

    - 각 큐는 서로 다른 우선순위 레벨을 할당받는다.

  - 작업이 실행 준비 완료되면,

    - 더 높은 우선순위를 가진 큐에 있는 작업이 선택된다.

    - 동일한 큐에 있는 작업끼리는 RR을 사용한다.
  
  - 각 작업의 우선순위는 작업의 관측된 행동(Observed behavior)에 따라 달라진다.

    - 5가지의 우선순위 규칙이 존재한다.

    - 규칙 1. IO bound는 cpu를 자주 양보하므로 높은 우선순위를 유지시킨다.

    - 규칙 2. cpu bound는 cpu를 독점하므로 낮은 우선순위로 내려버린다

    - 규칙 3. 작업이 시스템에 도착한 시점에, 가장 높은 우선순위에 배치된다.

    - 규칙 4a. 만약 작업이 자신의 time slice를 모두 사용했다면, 우선 순위를 내린다.

    - 규칙 4b. 자신의 time slice를 다 쓰지 않고 cpu를 양보했다면, 우선순위를 유지한다.

    - 이 규칙들을 통해 MLFQ는 SJF와 가깝게 행동한다.

  - 규칙 1, 2에 따라 MLFQ는 IO bound = Interactive한 작업을 계속 높은 우선순위로 유지시킨다.

  - 그럼 아무런 문제가 없나?

    - Starvation

      - Interactive한 작업이 많아지면, cpu bound(Long running) 작업들은 영영 cpu를 사용할 수 없다.

    - Trick the scheduler

      - time slice를 99퍼 사용하고 IO를 호출하면, 시간은 시간대로 먹고 우선순위를 계속 유지할 수 있다.

    - 시간에 따라 스스로의 행동을 바꾸는 프로그램

      - cpu bound -> IO bound로 바꿔도 우선순위는 계속 낮은 상태다.

  - 그럼 해결해보자.

    - Starvation

      - 규칙 5. 특정 시간 S가 지나면, 모든 작업을 제일 높은 큐로 올려버린다. (= Priority Boosting)

    - Tricking scheduler

      - 규칙 4(4a, 4b를 개정한다.). 작업이 자기 레벨에 할당된 총 시간제한(time allotment)를 다 사용하면, 우선순위를 내린다.

- 최종적인 MLFQ의 규칙은 다음과 같다.

  - 규칙 1: 만약 priority(A) > priority(B)면, A를 실행한다.

  - 규칙 2: 만약 priority(A) = priority(B)면 RR을 사용한다.

  - 규칙 3: 처음 도착한 모든 작업은 가장 높은 우선순위를 가진다.

  - 규칙 4: 작업이 자기 레벨에 맞는 time allotment를 소진하면, 우선 순위를 내린다.

  - 규칙 5: 특정 기간 S가 지나면 모든 작업을 최고 우선순위에 올린다.

  - 이를 통해 프로세스의 cpu 사용에 대한 사전 지식 없이도 SJF와 같은 기능을 기대할 수 있다.


