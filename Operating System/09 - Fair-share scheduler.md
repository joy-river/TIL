### Fair-share scheduler

---

- MLFQ는 대단한 알고리즘이지만, Fairness를 많이 고려하지 않으므로 특정 작업이 cpu를 받지 못하는 경우가 생길 수 있다.

- 따라서 Fairness를 중점으로하는 Fair-share 스케줄러를 만들었다.

  - turnaround time이나 response time은 고려하지 않는다.

  - 모든 작업이 일정비율의 cpu time을 획득하게 보장한다.

- 크게 두 종류로 나눌 수 있다.

  - randomized

    - Random number generator(RNG)를 사용하며, 만드는데 많은 비용이 든다.

  - deterministic

    - RNG를 사용하지 않아 비용을 절감할 수 있지만, 각 작업에 대한 state information이 필요하다.

- Ticket을 기본적인 컨셉으로 삼는다.

  - 티켓은 각 프로세스가 받아야 할 자원의 양을 대표한다.

  - 티켓의 퍼센티지가 각 시스템 자원의 양을 표시한다.

    - 프로세스 A가 75티켓을 가진다 = cpu의 75퍼센트를 받는다.

    - 프로세스 B가 25티켓을 가진다 = cpu의 25퍼센트를 받는다.

- Lottery scheduling

  - 스케줄러가 랜덤하게 당첨 티켓을 정한다.

  - 당첨된 프로세스의 상태를 불러와서 실행한다.

    - 프로세스 A가 75티켓을 가지면, 0 ~ 74는 A의 당첨 숫자가 된다.

    - 프로세스 B가 25티켓을 가지면, 75 ~ 99는 B의 당첨 숫자가 된다.

    - 60이 나오면 A를, 80이 나오면 B를 실행한다.

  - 많이 실행할 수록 티켓의 숫자만큼 실행될 확률이 커진다.

- 티켓의 여러 매커니즘을 알아보자.

  - Ticket currency

    - 사용자는 작업에 자신이 원하는 화폐단위(Currency)로 티켓을 할당할 수 있다.

    - 시스템이 이 단위를 적절한 전역 값으로 바꿔준다.

      - 비율에 맞게 조정해준다.

  - Ticket transfer

    - 프로세스는 일시적으로 다른 프로세스에 티켓을 넘겨줄 수 있다.

  - Ticket inflation

    - 프로세스는 자신의 티켓 숫자를 일시적으로 늘리거나 줄일 수 있다.

    - 만약 특정 프로세스가 cpu를 더 많이 필요로하면 스스로 티켓을 부스팅할 수 있다.

- Lottery의 구현은 단순하다.

  - 리스트의 프로세스들이 티켓 사이즈로 정렬되게 유지한다.

  - winner를 랜덤하게 결정하고,

  - 카운터에 각 티켓 값을 더해서 counter > winner가 될때 까지 반복한다.

- Lottery를 평가해보자.

  - F = Fairness metric

    - 첫 작업이 끝난 시간을 두 번째 작업이 끝난 시간으로 나눈다.

    - 첫 작업이 시간 10에, 두 번째가 시간 20에 끝났다면,

    > F = 10/20 = 0.5

    - 작업이 거의 동시에 끝났다면 F는 1에 가까워진다.

      - 즉, 스케줄링이 공평하게 진행되었을 수록 F는 1에 가깝다.

      - 위의 예시는 첫 작업이 다 끝나야 두 번째 작업이 실행되므로 최악에 가깝다.

      - 또는 작업 실행 시간이 너무 짧은 경우에도 F가 나빠질 수 있다.

- 랜덤이 아닌, 결정적(deterministic)인 접근을 해보자.

  - 문제는 프로세스를 하나 실행할 때 마다 일일히 티켓을 나눠주는게 가능한가?

  - 각 프로세스의 보폭(Stride)를 통한 접근을 한다.

    - 각 프로세스에 티켓을 주긴 할거다.

    - 큰 숫자 / 티켓으로 각 프로세스의 보폭을 정한다.

  - 티켓이 적을수록 보폭은 커진다.

  - 각 프로세스는 카운터(=pass value)를 가진다.

    - 프로세스가 실행될 때 마다 자기 보폭만큼 카운터를 증가시킨다.

    - 스케줄러는 모든 프로세스 중 가장 낮은 카운터를 가지는 프로세스를 실행시킨다.

    - 즉, 보폭이 적을 수록 = 티켓이 많을 수록 = 많은 cpu를 점유한다.

  - 따라서 보폭을 통한 스케줄링은 티켓의 수와 정확히 비례하는 스케줄링이 가능하다!

  - 그럼 아무런 문제가 없는가?

    - 새로운 작업이 들어오면 pass value가 0이므로 한동안 cpu를 독점한다.

    - pass value 값을 프로세스 하나마다 모두 저장해야한다.

      - Lottery 스케줄링은 이럴 필요가 없다.

- 실용적인 스케줄링 알고리즘을 살펴보자

- CFS(Completely Fair Scheduling)

  - 리눅스가 사용하는 여러 알고리즘 중 하나이며, 결정적인 알고리즘이다.

  - non-fixed time slice를 사용한다.

    - CFS가 동적 규칙에 따라 할당한다.

  - Priority

    - Nice 값을 사용해 우선순위를 통제할 수 있다.

  - Efficient data structures

    - red-black tree를 통한 프로세스의 효율적 탐색, 삽입, 삭제가 가능하다.

  - 기본적으로 Virtual runtime(vruntime)이라는 개념을 통해 Fairness를 달성한다.

    - vruntime은 프로세스가 실행된지 얼마나 시간이 지났는지 표시한다.

    - 각 프로세스마다 vruntime을 가지며, 프로세스가 실행될 때 마다 물리적 시간만큼 누적시킨다.

    - CFS는 가장 낮은 vruntime을 가지는 프로세스를 선택한다.

  - 이때 중요한 첫 번째 매개변수는 sched_latency이다.

    - 일반적으로 48msec로 지정되어있으며

    - 각 프로세스의 time slice = sched_latency / (# of process)가 된다.

      - 프로세스가 많아지면 짧은 시간동안, 프로세스가 적으면 오랜 시간동안 실행한다.

  - 두 번째 매개변수는 min_granularity이다.

        - time slice의 최소치이며, 6ms 값을 가진다.

        - 프로세스가 너무 많아졌을때, time slice가 짧아져 문맥 교환(스케줄링)에 너무 많은 지연이 발생하지 않게 막는다.

  - 세 번째 매개변수는 Nice value다.

        - CFS가 프로세스의 우선순위를 통제하게 하는 값이며, -20 ~ + 19까지의 값을 가질 수 있다.

        - 가중치(Weight)에 따라 달라진다.

        - 이 가중치를 통해 프로세스의 time slice를 계산할 수 있다.

        > time slice = weight / (모든 가중치의 합) * sched_latency

        - 따라서 다음과 같은 관계가 성립한다.

            - 높은 가중치 = 낮은 nice = 높은 우선순위 = 큰 time slice = 낮은 vruntime

            - 낮은 가중치 = 높은 nice = 낮은 우선순위 = 작은 time slice = 높은 vruntime

        - vruntime을 가중치를 통해 구할 수도 있다.

        > vruntime = vruntime + weight0 / weight * runtime

        - 이는 가중치와 반비례한다.

  - 또한 CFS는 Red-Black Tree를 사용해서 다음 프로세스를 효율적으로 찾을 수 있다.

    - Balaced binary tree이며, 최악의 경우에도 O(log n)으로 처리할 수 있다.

    - 아주 효율적으로 최소 vruntime = 다음 실행할 프로세스를 찾을 수 있다.

    - 모든 프로세스가 아니라, run, ready 상태의 프로세스만 저장한다.
